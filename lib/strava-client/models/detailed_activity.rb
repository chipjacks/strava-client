=begin
#Strava API v3

#The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.

OpenAPI spec version: 3.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require 'date'

module StravaClient

  class DetailedActivity
    # The unique identifier of the activity
    attr_accessor :id

    # The identifier provided at upload time
    attr_accessor :external_id

    # The identifier of the upload that resulted in this activity
    attr_accessor :upload_id

    attr_accessor :athlete

    # The name of the activity
    attr_accessor :name

    # The activity's distance, in meters
    attr_accessor :distance

    # The activity's moving time, in seconds
    attr_accessor :moving_time

    # The activity's elapsed time, in seconds
    attr_accessor :elapsed_time

    # The activity's total elevation gain.
    attr_accessor :total_elevation_gain

    # The activity's highest elevation, in meters
    attr_accessor :elev_high

    # The activity's lowest elevation, in meters
    attr_accessor :elev_low

    attr_accessor :type

    # The time at which the activity was started.
    attr_accessor :start_date

    # The time at which the activity was started in the local timezone.
    attr_accessor :start_date_local

    # The timezone of the activity
    attr_accessor :timezone

    attr_accessor :start_latlng

    attr_accessor :end_latlng

    # The number of achievements gained during this activity
    attr_accessor :achievement_count

    # The number of kudos given for this activity
    attr_accessor :kudos_count

    # The number of comments for this activity
    attr_accessor :comment_count

    # The number of athletes for taking part in a group activity
    attr_accessor :athlete_count

    # The number of Instagram photos for this activity
    attr_accessor :photo_count

    # The number of Instagram and Strava photos for this activity
    attr_accessor :total_photo_count

    attr_accessor :map

    # Whether this activity was recorded on a training machine
    attr_accessor :trainer

    # Whether this activity is a commute
    attr_accessor :commute

    # Whether this activity was created manually
    attr_accessor :manual

    # Whether this activity is private
    attr_accessor :private

    # Whether this activity is flagged
    attr_accessor :flagged

    # The activity's workout type
    attr_accessor :workout_type

    # The unique identifier of the upload in string format
    attr_accessor :upload_id_str

    # The activity's average speed, in meters per second
    attr_accessor :average_speed

    # The activity's max speed, in meters per second
    attr_accessor :max_speed

    # Whether the logged-in athlete has kudoed this activity
    attr_accessor :has_kudoed

    # The id of the gear for the activity
    attr_accessor :gear_id

    # The total work done in kilojoules during this activity. Rides only
    attr_accessor :kilojoules

    # Average power output in watts during this activity. Rides only
    attr_accessor :average_watts

    # Whether the watts are from a power meter, false if estimated
    attr_accessor :device_watts

    # Rides with power meter data only
    attr_accessor :max_watts

    # Similar to Normalized Power. Rides with power meter data only
    attr_accessor :weighted_average_watts

    # The description of the activity
    attr_accessor :description

    attr_accessor :photos

    attr_accessor :gear

    # The number of kilocalories consumed during this activity
    attr_accessor :calories

    attr_accessor :segment_efforts

    # The name of the device used to record the activity
    attr_accessor :device_name

    # The token used to embed a Strava activity
    attr_accessor :embed_token

    # The splits of this activity in metric units (for runs)
    attr_accessor :splits_metric

    # The splits of this activity in imperial units (for runs)
    attr_accessor :splits_standard

    attr_accessor :laps

    attr_accessor :best_efforts


    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'id' => :'id',
        :'external_id' => :'external_id',
        :'upload_id' => :'upload_id',
        :'athlete' => :'athlete',
        :'name' => :'name',
        :'distance' => :'distance',
        :'moving_time' => :'moving_time',
        :'elapsed_time' => :'elapsed_time',
        :'total_elevation_gain' => :'total_elevation_gain',
        :'elev_high' => :'elev_high',
        :'elev_low' => :'elev_low',
        :'type' => :'type',
        :'start_date' => :'start_date',
        :'start_date_local' => :'start_date_local',
        :'timezone' => :'timezone',
        :'start_latlng' => :'start_latlng',
        :'end_latlng' => :'end_latlng',
        :'achievement_count' => :'achievement_count',
        :'kudos_count' => :'kudos_count',
        :'comment_count' => :'comment_count',
        :'athlete_count' => :'athlete_count',
        :'photo_count' => :'photo_count',
        :'total_photo_count' => :'total_photo_count',
        :'map' => :'map',
        :'trainer' => :'trainer',
        :'commute' => :'commute',
        :'manual' => :'manual',
        :'private' => :'private',
        :'flagged' => :'flagged',
        :'workout_type' => :'workout_type',
        :'upload_id_str' => :'upload_id_str',
        :'average_speed' => :'average_speed',
        :'max_speed' => :'max_speed',
        :'has_kudoed' => :'has_kudoed',
        :'gear_id' => :'gear_id',
        :'kilojoules' => :'kilojoules',
        :'average_watts' => :'average_watts',
        :'device_watts' => :'device_watts',
        :'max_watts' => :'max_watts',
        :'weighted_average_watts' => :'weighted_average_watts',
        :'description' => :'description',
        :'photos' => :'photos',
        :'gear' => :'gear',
        :'calories' => :'calories',
        :'segment_efforts' => :'segment_efforts',
        :'device_name' => :'device_name',
        :'embed_token' => :'embed_token',
        :'splits_metric' => :'splits_metric',
        :'splits_standard' => :'splits_standard',
        :'laps' => :'laps',
        :'best_efforts' => :'best_efforts'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'id' => :'Integer',
        :'external_id' => :'String',
        :'upload_id' => :'Integer',
        :'athlete' => :'MetaAthlete',
        :'name' => :'String',
        :'distance' => :'Float',
        :'moving_time' => :'Integer',
        :'elapsed_time' => :'Integer',
        :'total_elevation_gain' => :'Float',
        :'elev_high' => :'Float',
        :'elev_low' => :'Float',
        :'type' => :'ActivityType',
        :'start_date' => :'DateTime',
        :'start_date_local' => :'DateTime',
        :'timezone' => :'String',
        :'start_latlng' => :'LatLng',
        :'end_latlng' => :'LatLng',
        :'achievement_count' => :'Integer',
        :'kudos_count' => :'Integer',
        :'comment_count' => :'Integer',
        :'athlete_count' => :'Integer',
        :'photo_count' => :'Integer',
        :'total_photo_count' => :'Integer',
        :'map' => :'PolylineMap',
        :'trainer' => :'BOOLEAN',
        :'commute' => :'BOOLEAN',
        :'manual' => :'BOOLEAN',
        :'private' => :'BOOLEAN',
        :'flagged' => :'BOOLEAN',
        :'workout_type' => :'Integer',
        :'upload_id_str' => :'String',
        :'average_speed' => :'Float',
        :'max_speed' => :'Float',
        :'has_kudoed' => :'BOOLEAN',
        :'gear_id' => :'String',
        :'kilojoules' => :'Float',
        :'average_watts' => :'Float',
        :'device_watts' => :'BOOLEAN',
        :'max_watts' => :'Integer',
        :'weighted_average_watts' => :'Integer',
        :'description' => :'String',
        :'photos' => :'PhotosSummary',
        :'gear' => :'SummaryGear',
        :'calories' => :'Float',
        :'segment_efforts' => :'Array<DetailedSegmentEffort>',
        :'device_name' => :'String',
        :'embed_token' => :'String',
        :'splits_metric' => :'Array<Split>',
        :'splits_standard' => :'Array<Split>',
        :'laps' => :'Array<Lap>',
        :'best_efforts' => :'Array<DetailedSegmentEffort>'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'external_id')
        self.external_id = attributes[:'external_id']
      end

      if attributes.has_key?(:'upload_id')
        self.upload_id = attributes[:'upload_id']
      end

      if attributes.has_key?(:'athlete')
        self.athlete = attributes[:'athlete']
      end

      if attributes.has_key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.has_key?(:'distance')
        self.distance = attributes[:'distance']
      end

      if attributes.has_key?(:'moving_time')
        self.moving_time = attributes[:'moving_time']
      end

      if attributes.has_key?(:'elapsed_time')
        self.elapsed_time = attributes[:'elapsed_time']
      end

      if attributes.has_key?(:'total_elevation_gain')
        self.total_elevation_gain = attributes[:'total_elevation_gain']
      end

      if attributes.has_key?(:'elev_high')
        self.elev_high = attributes[:'elev_high']
      end

      if attributes.has_key?(:'elev_low')
        self.elev_low = attributes[:'elev_low']
      end

      if attributes.has_key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.has_key?(:'start_date')
        self.start_date = attributes[:'start_date']
      end

      if attributes.has_key?(:'start_date_local')
        self.start_date_local = attributes[:'start_date_local']
      end

      if attributes.has_key?(:'timezone')
        self.timezone = attributes[:'timezone']
      end

      if attributes.has_key?(:'start_latlng')
        self.start_latlng = attributes[:'start_latlng']
      end

      if attributes.has_key?(:'end_latlng')
        self.end_latlng = attributes[:'end_latlng']
      end

      if attributes.has_key?(:'achievement_count')
        self.achievement_count = attributes[:'achievement_count']
      end

      if attributes.has_key?(:'kudos_count')
        self.kudos_count = attributes[:'kudos_count']
      end

      if attributes.has_key?(:'comment_count')
        self.comment_count = attributes[:'comment_count']
      end

      if attributes.has_key?(:'athlete_count')
        self.athlete_count = attributes[:'athlete_count']
      end

      if attributes.has_key?(:'photo_count')
        self.photo_count = attributes[:'photo_count']
      end

      if attributes.has_key?(:'total_photo_count')
        self.total_photo_count = attributes[:'total_photo_count']
      end

      if attributes.has_key?(:'map')
        self.map = attributes[:'map']
      end

      if attributes.has_key?(:'trainer')
        self.trainer = attributes[:'trainer']
      end

      if attributes.has_key?(:'commute')
        self.commute = attributes[:'commute']
      end

      if attributes.has_key?(:'manual')
        self.manual = attributes[:'manual']
      end

      if attributes.has_key?(:'private')
        self.private = attributes[:'private']
      end

      if attributes.has_key?(:'flagged')
        self.flagged = attributes[:'flagged']
      end

      if attributes.has_key?(:'workout_type')
        self.workout_type = attributes[:'workout_type']
      end

      if attributes.has_key?(:'upload_id_str')
        self.upload_id_str = attributes[:'upload_id_str']
      end

      if attributes.has_key?(:'average_speed')
        self.average_speed = attributes[:'average_speed']
      end

      if attributes.has_key?(:'max_speed')
        self.max_speed = attributes[:'max_speed']
      end

      if attributes.has_key?(:'has_kudoed')
        self.has_kudoed = attributes[:'has_kudoed']
      end

      if attributes.has_key?(:'gear_id')
        self.gear_id = attributes[:'gear_id']
      end

      if attributes.has_key?(:'kilojoules')
        self.kilojoules = attributes[:'kilojoules']
      end

      if attributes.has_key?(:'average_watts')
        self.average_watts = attributes[:'average_watts']
      end

      if attributes.has_key?(:'device_watts')
        self.device_watts = attributes[:'device_watts']
      end

      if attributes.has_key?(:'max_watts')
        self.max_watts = attributes[:'max_watts']
      end

      if attributes.has_key?(:'weighted_average_watts')
        self.weighted_average_watts = attributes[:'weighted_average_watts']
      end

      if attributes.has_key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.has_key?(:'photos')
        self.photos = attributes[:'photos']
      end

      if attributes.has_key?(:'gear')
        self.gear = attributes[:'gear']
      end

      if attributes.has_key?(:'calories')
        self.calories = attributes[:'calories']
      end

      if attributes.has_key?(:'segment_efforts')
        if (value = attributes[:'segment_efforts']).is_a?(Array)
          self.segment_efforts = value
        end
      end

      if attributes.has_key?(:'device_name')
        self.device_name = attributes[:'device_name']
      end

      if attributes.has_key?(:'embed_token')
        self.embed_token = attributes[:'embed_token']
      end

      if attributes.has_key?(:'splits_metric')
        if (value = attributes[:'splits_metric']).is_a?(Array)
          self.splits_metric = value
        end
      end

      if attributes.has_key?(:'splits_standard')
        if (value = attributes[:'splits_standard']).is_a?(Array)
          self.splits_standard = value
        end
      end

      if attributes.has_key?(:'laps')
        if (value = attributes[:'laps']).is_a?(Array)
          self.laps = value
        end
      end

      if attributes.has_key?(:'best_efforts')
        if (value = attributes[:'best_efforts']).is_a?(Array)
          self.best_efforts = value
        end
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@athlete_count.nil? && @athlete_count < 1
        invalid_properties.push("invalid value for 'athlete_count', must be greater than or equal to 1.")
      end

      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@athlete_count.nil? && @athlete_count < 1
      return true
    end

    # Custom attribute writer method with validation
    # @param [Object] athlete_count Value to be assigned
    def athlete_count=(athlete_count)

      if !athlete_count.nil? && athlete_count < 1
        fail ArgumentError, "invalid value for 'athlete_count', must be greater than or equal to 1."
      end

      @athlete_count = athlete_count
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          id == o.id &&
          external_id == o.external_id &&
          upload_id == o.upload_id &&
          athlete == o.athlete &&
          name == o.name &&
          distance == o.distance &&
          moving_time == o.moving_time &&
          elapsed_time == o.elapsed_time &&
          total_elevation_gain == o.total_elevation_gain &&
          elev_high == o.elev_high &&
          elev_low == o.elev_low &&
          type == o.type &&
          start_date == o.start_date &&
          start_date_local == o.start_date_local &&
          timezone == o.timezone &&
          start_latlng == o.start_latlng &&
          end_latlng == o.end_latlng &&
          achievement_count == o.achievement_count &&
          kudos_count == o.kudos_count &&
          comment_count == o.comment_count &&
          athlete_count == o.athlete_count &&
          photo_count == o.photo_count &&
          total_photo_count == o.total_photo_count &&
          map == o.map &&
          trainer == o.trainer &&
          commute == o.commute &&
          manual == o.manual &&
          private == o.private &&
          flagged == o.flagged &&
          workout_type == o.workout_type &&
          upload_id_str == o.upload_id_str &&
          average_speed == o.average_speed &&
          max_speed == o.max_speed &&
          has_kudoed == o.has_kudoed &&
          gear_id == o.gear_id &&
          kilojoules == o.kilojoules &&
          average_watts == o.average_watts &&
          device_watts == o.device_watts &&
          max_watts == o.max_watts &&
          weighted_average_watts == o.weighted_average_watts &&
          description == o.description &&
          photos == o.photos &&
          gear == o.gear &&
          calories == o.calories &&
          segment_efforts == o.segment_efforts &&
          device_name == o.device_name &&
          embed_token == o.embed_token &&
          splits_metric == o.splits_metric &&
          splits_standard == o.splits_standard &&
          laps == o.laps &&
          best_efforts == o.best_efforts
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [id, external_id, upload_id, athlete, name, distance, moving_time, elapsed_time, total_elevation_gain, elev_high, elev_low, type, start_date, start_date_local, timezone, start_latlng, end_latlng, achievement_count, kudos_count, comment_count, athlete_count, photo_count, total_photo_count, map, trainer, commute, manual, private, flagged, workout_type, upload_id_str, average_speed, max_speed, has_kudoed, gear_id, kilojoules, average_watts, device_watts, max_watts, weighted_average_watts, description, photos, gear, calories, segment_efforts, device_name, embed_token, splits_metric, splits_standard, laps, best_efforts].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = StravaClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
